## ■可変長引数													
													
	〇概要												
		引数が同じ型であれば、引数を任意の数設定することができる。											
													
	〇形式												
		引数の型の後に.を3つつける											
		static void Method(String... s){}											
													
		※可変長引数を二つ以上含む場合は、可変長引数を最後に記述しないとコンパイルエラーになる。											
		（可変長引数の後の引数がどこからなのか判断できないため）											
													
## ■エスケープとダブルクオテーション													
													
	〇エスケープ													\"	⇒	"									
													
	〇ダブルクオテーション
    "a b"c　⇒　a bc											
													
													
## ■var													
													
	〇決まり												
		・varによる型推論はローカル変数の宣言にしか使えない。											
		(=フィールドやメソッド引数の型宣言には使用できない）											
													
													
## ■String													
													
	〇valueOf												
		Stringを生成するメソッド。											
		staticなメソッドのため、インスタンスを生成しないで使用できる。											
		（Stringはコンパイラが勝手に判断して）											
		例）String s = "aaa";											
			s = String.valueOf("bbb");										
													
	〇indexOf												
		文字列の中を検索し、そのindexを返すメソッド。											
		引数に文字列を指定した場合は、その文字列がはじまるindexを返す。											
		ない場合は-1を返す。											
		例)	String s = "abcde";										
			int aIndex = s.indexOf("a");								//aIndex: 0		
													
	〇concat												
		文字列を結合する。											
		String hello = "Hello";											
		hello.concat(" Java!");								//Hello Java!			
													
## ■StringBuilder													
	〇概要												
		保持している文字列+16文字のバッファを持つ。											
		（文字列を渡した場合は、その文字数+16文字のchar配列が生成される）											
													
	〇capacity												
		容量を返すメソッド。											
		StringBuilder sb = new StringBuilder("abcde");											
		int cap = sb.capacity();							//cap: 21				
													
	〇indexof												
		指定された部分文字列が最初に出現する位置のインデックスを返す。											
		StringBuilder sb = new StringBuilder("abcde");											
		int index = sb.indexOf("ab");							//index = 0				
													
													
## ■数値型													
													
	〇int⇒short												
		大きな範囲の型の変数を小さな範囲の型の変数に代入するときは											
		明示的なキャストが必要。											
			int a = 10;										
			short b = (short) a;										
		明示的にキャストすると、型の範囲を超えていてもコンパイルエラーが生じない。											
		ただしあふれたが切り捨てられて想定外の結果になるため、注意。											
			byte b = (byte)150;						//-106				
													
	〇数値型の範囲												
		byte		：	-128~127                        (8bit)	
		short		：	-32768~32,767	                (16bit)	
		int			：	-2,147,483,648~2,147,483,647	(32bit)	
		long		：	                                (64bit)	
		float		：	                                (32bit)	
		double		：	                                (64bit)	
													
													
													
	〇サフィックス												
		int型の範囲を超える数値は、後ろにLをつける											
		double型の後ろはＤ											
		float型の後ろはFをつける											
													
	〇&と&&、|と||												
													
		&と&&、｜と||の違いは、左オペランドの結果で右オペランドを評価するか、しないか。											
		記号を二つつなげたものはショートサーキット演算子ともいわれ、											
		左のオペランドで確定する場合は右オペランドを評価しない。											
													
## ■コンスタントプール													
													
	〇概要												
		文字リテラルはプログラム中に頻繁に表れるため、そのたびにインスタンスを生成すると											
		処理の負荷が高くなり、メモリも大量に消費することになる。											
		そのため、もし同じ文字列リテラルがプログラム内に再び登場すれば、定数用のメモリ空間にある											
		文字列インスタンスへの参照が使いまわしされる。											
		この仕組みをコンスタントプールという。											
													
		例	String a = "Sample";										
			String b = "Sample";										
			System.out.println(a == b);								//true		
			※String a = new String("Sample");とすると、										
			明示的にインスタンスを生成することになるため										
			コンスタントプールは利用されずfalseになる										
													
	〇intern()												
		Stringクラスのinternメソッドは、コンスタントプールを含むメモリ内の文字列を探して											
		再利用するためのメソッド。											
		例	String a = new String("Sample");										
			String b = new String("Sample");										
			System.out.println(a.intern() == b.intern());										//true
													
## ■条件、繰り返し文													
													
	〇if												
		if文の中カッコは省略できる。省略した場合は、条件式の次の一文だけが											
		条件に合致したときの処理として実行される。											
													
	〇case文												
		case文の条件式が戻す値には型の制限がある。											
		OK:	int型以下の整数型とそのラッパークラス										
			文字と文字列										
			列挙型										
		NG:	Long型、boolean型、doubleやfloat型										
													
	〇do while												
		do{処理}while(条件式);											
													
	〇do whileの中カッコ省略												
		while文やdo while文も中カッコを省略できる											
		ただし、do whileで中カッコを省略する場合は、											
		中の処理を1行にしないとコンパイルエラーが発生する。											
													
	〇for文												
		複数記述できるのは初期化文と更新文のみ											
		条件式は複数書けない											
													
	〇ラベル												
		処理を途中で抜けて特定の場所に飛ぶことができる。											
		下記コードでのsampleがラベルにあたる。											
		sample:											
			for(i = 0; i < 5; i++){										
				if(I = 3){									
					break sample;								
				}									
			}										
													
## ■繰り返し文													
													
	〇配列の宣言												
		配列の宣言時、[]は変数の前後どちらでもOK											
		int[] a;			//OK								
		int a[];			//OK								
		int []a[];			//OK								
													
		配列型変数には配列インスタンスへの参照を代入するだけで、											
		参照先の配列がいくつの要素を扱えるかは関係ない。											
		あくまで配列型は型であり、インスタンスの実装する部分（要素数）を型には記述できない。											
		int[3] = new int[3];					//NG						
													
		宣言時、一次元は省略できないが、二次元をあとから記述することはできる											
		int[][] a = new int[3][];											
		a[0] = new int[3];											
		a[1] = new int[3];											
		a[2] = new int[3];											
													
		インスタンスを生成する際、大かっこの後に初期化子{}を記述することも可能。											
		ただし、大かっこの中に要素数を指定してはいけない。											
		int[] array = {2,3};											
		int[] array = new int[]{2,3};							//OK				
		int[] array = new int[2]{2,3};							//コンパイルエラー				
													
		要素数0のインスタンスを生成することも可能											
		int [] array = {};											
													
		初期化子｛｝を使う場合は、変数の宣言と同時に行わなければならない。											
													
													
## ■ガーベージコレクション													
													
		Java言語ではJVMのガベージコレクタがメモリ上の使われなくなったインスタンスを探し、											
		そのインスタンスを破棄してメモリを解放する。											
		ガベージコレクションの対象は、どこからも参照されなくなったインスタンス											
													
													
## ■コンストラクタ													
													
	〇初期子												
		・コンストラクタもオーバーロードできるが、すべてのコンストラクタで共通に呼び出すメソッドを{}で定義できる											
													
		public class Sample(){											
			Sample(){ System.out.println("A");										
			}										
			{	System.out.println("B");									
			}										
		}			//mainクラスでインスタンス生成⇒"ＢＡ"が出力される								
													
		初期子はstaticをつけることもできる											
													
		public class Sample(){											
			static int num;										
			Sample(){ System.out.println("A");										
			}										
		static	{	num = 10;									
			}										
		}			//mainクラスでSample.num呼び出し⇒　numに10が代入される								
													
	〇デフォルトコンストラクタ												
		・コンストラクタを定義しなかった場合、引数なしのデフォルトコンストラクタが自動で定義されるが、											
		　引数ありのコンストラクタを定義した場合はデフォルトコンストラクタは自動で定義されない。											
													
	〇コンストラクタのオーバーロード												
		・オーバーロードした別のコンストラクタを呼び出すときはthisを使用する											
		　※superは親クラスのコンストラクタを呼び出す											
		　※オーバーロードされた別のコンストラクタを呼び出すthisを使う場合は、最初に書かないといけない											
													
													
	〇インターフェースへの実装の記述												
		基本的にインターフェースに実装を書くことはできないが、											
		共通的に実行される処理について、											
		defaultをつけてインターフェース中に記述することができる。											
		※ただしObjectクラスのメソッドをオーバーライドするとコンパイルエラーとなる。											
